# Обзор архитектуры

Система изучения флеш-карточек построена с использованием гексагональной архитектуры (также известной как архитектура портов и адаптеров). Эта архитектура разделяет приложение на несколько слоев:

1. Домен (Domain):
    - Содержит основные бизнес-сущности (Card, Deck) и их базовую логику.
    - Находится в пакете domain.entities.

2. Приложение (Application):
    - Содержит use cases, сервисы, порты, DTO и бизнес-логику.
    - Включает фабрики, стратегии и наблюдателей.
    - Находится в пакете application и его подпакетах.

3. Инфраструктура (Infrastructure):
    - Содержит реализации для взаимодействия с внешними системами.
    - Включает репозитории и адаптеры.
    - Находится в пакете infrastructure.

4. Представление (Presentation):
    - Содержит пользовательский интерфейс и команды.
    - Находится в пакете presentation.

## Ключевые компоненты

1. Entities (Card, Deck): Основные бизнес-объекты системы.
2. Use Cases: Реализуют бизнес-логику приложения.
3. Ports: Определяют интерфейсы для взаимодействия между слоями.
4. Adapters: Реализуют порты для взаимодействия с внешними системами.
5. Services: Координируют работу различных компонентов системы.
6. Factories: Создают объекты различных типов.
7. Strategies: Определяют алгоритмы изучения карточек.
8. Observers: Следят за процессом изучения и обновляют статистику.
9. Commands: Инкапсулируют действия пользователя.

## Преимущества архитектуры

1. Слабая связанность: Компоненты слабо связаны между собой, что облегчает тестирование и поддержку.
2. Гибкость: Легко заменять компоненты без влияния на другие части системы.
3. Тестируемость: Архитектура способствует написанию модульных тестов.
4. Расширяемость: Легко добавлять новые функции и компоненты.

## Детальное описание паттернов проектирования

### Порождающие паттерны
1. Factory Method
   - Интерфейс: CardFactory
   - Реализации: TextCardFactory, ImageCardFactory
   - Назначение: Создание различных типов карточек без привязки к конкретным классам
   - Преимущества: Легкое добавление новых типов карточек

2. Singleton
   - Реализация: InMemoryDeckRepository
   - Назначение: Обеспечение единственного экземпляра хранилища данных
   - Преимущества: Централизованное управление данными

### Структурные паттерны
1. Decorator
   - Базовый класс: CardDecorator
   - Реализации: TimedCard
   - Назначение: Динамическое добавление функциональности карточкам
   - Преимущества: Расширение функциональности без изменения существующего кода

2. Adapter
   - Реализация: FileSystemAdapter
   - Назначение: Адаптация файловой системы для сохранения колод
   - Преимущества: Изоляция деталей хранения данных

### Поведенческие паттерны
1. Observer
   - Интерфейс: StudyObserver
   - Реализация: StudyProgressObserver
   - Назначение: Отслеживание прогресса изучения карточек
   - Преимущества: Слабая связанность между компонентами

2. Strategy
   - Интерфейс: StudyStrategy
   - Реализации: RandomStudyStrategy, DifficultyBasedStrategy
   - Назначение: Определение различных алгоритмов изучения карточек
   - Преимущества: Легкое переключение между стратегиями

3. Command
   - Интерфейс: Command
   - Реализации: CreateDeckCommand, StudyDeckCommand, AddCardCommand и др.
   - Назначение: Инкапсуляция действий пользователя
   - Преимущества: Единый интерфейс для всех команд, возможность отмены операций

## Диаграммы взаимодействия

### Процесс изучения карточек
1. Пользователь выбирает колоду через ConsoleUI
2. StudyDeckCommand получает карточки через DeckService
3. StudyStrategy определяет порядок карточек
4. StudyObserver отслеживает прогресс
5. Результаты сохраняются через DeckPersistenceOutputPort

### Процесс создания карточек
1. Пользователь вводит данные через ConsoleUI
2. AddCardCommand обрабатывает ввод
3. CardFactory создает соответствующий тип карточки
4. DeckService добавляет карточку в колоду
5. Изменения сохраняются через DeckPersistenceOutputPort
